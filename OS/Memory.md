# 内存管理

## 背景

### 基本硬件

- 基地址寄存器(base register) 含有最小的合法物理内存地址
- 界限地址寄存器(limit register) 决定了范围的大小

## 地址

### Addresses given in different way

- Symbolic Address
- Relocatable Address
- Absolute Address

### 地址绑定

源程序中的地址通过符号表示，编译器需要将这些符号地址绑定(bind)在可重定位的地址，链接器或加载程序将这些可重定位的地址绑定成绝对地址

- 编译时：如果编译时就知道进程将在内存中的驻留地址，那么就可以生成绝对代码。如果将来开始地址发生变化，那么必须重新编译代码
- 加载时：如果在编译时不知道进程将驻留在内存的什么地方，那么编译器必须生成可重定位代码。绑定会延迟到加载时才执行
- 执行时：如果进程在执行是可以从一个内存转移到另一个内存段，那么绑定必须延迟到执行时才进行。绝大多数计算机操作系统采用这种方法

### 逻辑地址空间和物理地址空间

- 逻辑地址：CPU生成的地址（通常成为虚拟地址）
- 物理地址：内存单元看到的地址（即加载道内存地址寄存器中的地址）
- 执行时的内存绑定导致不同的逻辑地址和物理地址
- 虚拟地址到物理地址的映射由内存管理单元(memory-management unit, MMU)完成

### 动态加载

动态加载：一个子程序只有在调用时才被加载，所有子程序都以可重定位的形式保存在磁盘上

### 动态链接

优点：

- 节约内存空间
- 减小可执行文件大小
- 添加新的库不需要重新链接

Dynamically linking also known as shared libraries.

## 连续内存分配(contiguous memory allocation)

内存分为两个区域

- 驻留操作系统（低内存）
- 用于用户进程（高内存）

### 内存映射与保护

重定位寄存器和界限地址寄存器

### 内存分配

- 多分区方法

动态存储分配问题

- First-fit
- Best-fit
- Worst-fit

### 碎片

- 外部碎片问题
- 内部碎片问题：进程所分配的内存可能比所要的要大

解决外部碎片问题

- 紧缩(compaction)：移动内存内容，以便所有空闲空间合并成一整块，并非总是可能的

## 分页(paging)

- 将物理内存分为固定大小的块，称为帧(frame)
- 将逻辑内存分为同样大小的块，称为页(page)

CPU 生成的每个地址分为两部分：页号(p)和页偏移(d)

### 硬件实现

- Page table is kept in memory
- 页表基寄存器(page-table base register, PTBR)
- 转换表缓冲(translation look-aside buffer, TLB)

## 页表

### 层次页表
