# 链接

链接是将各种代码和数据片段收集并组合成一个单一文件，使得分离编译成为可能

链接可以执行于：

- 编译时
- 加载时
- 运行时

学习之前，为什么学习链接？

- 理解链接器帮助你构建大型程序
- 理解链接器帮助你避免一些危险的编程错误
- 理解链接帮助你理解语言的作用域规则时如何实现的：全局、局部、静态等
- 理解链接帮助你理解其他重要的概念：加载、运行、虚拟内存、分页、内存映射
- 理解链接使你能够利用共享库

## 链接的过程

e.g. 编译 main.c sum.c

```bash
gcc -Og -o prog main.c sum.c
```

- 驱动程序运行 C 预处理器(cpp)，将 C 的源程序 main.c 翻译成一个 ASCII 码的中间文件 main.i

```bash
cpp [arguments] main.c /tmp/main.i
```

- 驱动程序运行 C 编译器(cc1)，将 main.i 编译成 ASCII 汇编文件 main.s

```bash
cc1 /tmp/main.i -Og [arguments] -o /tmp/main.s
```

- 驱动程序运行汇编其(as)，将 main.s 翻译成一个可重定向目标文件(relocatable object file) main.o

```bash
as [arguments] -o /tmp/main.o /tmp/main.s
```

- 驱动程序经过相同步骤生成 sum.o，运行链接器ld，生成可执行目标文件 prog

```bash
ld -o prog [arguments] /tmp/main.o /tmp/sum.o
```

## 静态链接

上述方法成为静态链接。链接器完成两个主要任务：

- 符号解析(symbol resolution)
- 重定位(relocation)

## 可重定位目标文件

ELF头包含了帮助链接器语法分析和解释目标文件的信息

## 符号和符号表

每个可冲定位目标模块m都有一个符号表，包含m定义和引用的符号的信息。有三种不同符号

- 由模块m定义且能被其他模块引用的全局符号。对应于非静态的C函数和全局变量
- 有其他模块定义并被模块m引用的全局符号
- 只被模块m定义和引用的局部符号。对应于static的C函数和全局变量

其中

- .symtab中的符号表不包含对应与本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣
- static的本地变量是不在栈中管理的，编译器在.data and .bss 中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号
- C语言使用static属性隐藏模块内部的变量和函数声明。任何带有static属性声明的全部变量或者函数都是模块私有的；任何不带static属性声明的全局变量和函数都是公共的

另外

- GNU READELF 可用来查看目标文件内容

## 符号解析

链接器解析符号引用：将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来

- 编译器只允许每个模块中每个局部符号有一个定义
- 静态局部变量也会有本地链接诶其符号，编译器还要确保他们拥有唯一的名字

> **C++ 和 Java 中链接器符号的重整**
> C++ 和 Java 中可以使用重载，因为编译器将每个唯一的方法和参数列表组合编码成一个唯一的名字，叫做重整(mangling) 

### 链接器如何解析多重定义的全局符号

当多个模块定义同名的全局符号，会发生什么？linux采用以下做法：

- 在编译时，编译器向汇编器输出每个全局符号，函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号
- 根据强弱符号的定义，linux链接器采用如下规则：
  - 不允许有多个同名的强符号
  - 如果有一个强符号和多个弱符号同名，选择强符号
  - 如果有多个弱符号同名，那么任意选择一个
- 规则2和3会造成一些不宜察觉的错误

e.g.

```c
// foo.c
#include <stdio.h>
void f(void);

int x = 15213;

int main()
{
    f();
    printf("x = %d\n", x);
    return 0;
}

// bar.c
int x;

void f()
{
    x = 15212;
}
```

- 在运行时，函数f将x的值由15213改为15212，会给main函数的作者带来意外！
- 如果x有两个若定义，也会发生相似的事情

e.g. 如果x在一个模块中被定义为int，在另一个模块中被定义为double

```c
// foo.c
#include <stdio.h>
void f(void);

int y = 15212;
int x = 15213;

int main()
{
    f();
    printf("x = 0x%x y = 0x%x\n", x, y);
    return 0;
}

// bar.c
double x;
void f()
{
    x = -0.0;
}
```

在一台x86-64的linux机器上，x的地址是0x601020, y的地址是0x601024，因此bar中的复制将用负零的双精度浮点表示覆盖x和y的位置. 输出：

```
x = 0x0 y = 0x80000000
```

当你怀疑有此类错误时，用像 GCC-fno-common标志这样的选项调用链接器。遇到多重定义的全局符号时，触发一个错误
