# 拷贝控制

## 拷贝构造

- 拷贝构造不应该是explicit的，因为拷贝构造函数在多种情况下会被隐式地使用。

## 析构函数

析构函数被自动调用，当
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（标准库容器或数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用运算符delete时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

## 三/五法则

- 需要析构函数的类也需要拷贝和赋值操作
- 需要拷贝操作的类也需要赋值操作，反之亦然

## 阻止拷贝

- 在某些类中，拷贝构造和拷贝赋值没有合理的意义，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止拷贝，以避免多个对象写入或读取相同的IO缓冲。
- 与 `=default` 不同，`=delete`必须出现在函数第一次声明的时候。因此`=delete`直到编译器生成代码时才需要。
e.g.

```cpp
struct NoCopy
{
    NoCopy() = default;                            // 合成的默认构造函数
    NoCopy(const NoCopy &) = delete;               // 阻止拷贝
    NoCopy &operator = (const NoCopy &) = delete;  // 阻止赋值
    ~NoCopy() = default;                           // 使用合成的析构函数
}
```

- 析构函数不能是删除的成员
- 合成的拷贝控制成员可能是删除的

对于某些类来说，编译器将这些合成的成员定义为可删除的函数：
- 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
- 如果类的某个成员的拷贝构造函数/析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为是删除的
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数被定义为删除的

- 可通过将类的拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝

